Main Integration File

/*
 * Redis-TCP Server - Main Integration File
 * 
 * This file provides the complete integration that ties together:
 * - Raw packet I/O (AF_PACKET)
 * - TCP/IP stack
 * - RESP protocol parser
 * - Redis-like command handlers
 * - Data structures (hash tables, lists, sorted sets)
 * 
 * Author: Systems Engineering AI
 * Date: 2024
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>
#include <time.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <net/ethernet.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <linux/if_packet.h>
#include <linux/if_ether.h>

/* ============================================================================
 * FORWARD DECLARATIONS & INCLUDES
 * ============================================================================ */

// Include all the implementation files (in practice, these would be headers)
// For now, we'll include key structures and function declarations

// From tcp_stack.c
typedef enum {
    TCP_CLOSED,
    TCP_LISTEN,
    TCP_SYN_SENT,
    TCP_SYN_RCVD,
    TCP_ESTABLISHED,
    TCP_FIN_WAIT_1,
    TCP_FIN_WAIT_2,
    TCP_CLOSE_WAIT,
    TCP_CLOSING,
    TCP_LAST_ACK,
    TCP_TIME_WAIT
} tcp_state_t;

typedef struct tcp_connection tcp_connection_t;
typedef struct conn_pool conn_pool_t;
typedef struct hash_table hash_table_t;
typedef struct resp_parser resp_parser_t;
typedef struct timing_wheel timing_wheel_t;

// Protocol constants
#define ETH_ALEN 6
#define IP_PROTO_TCP 6
#define IP_PROTO_ICMP 1

// TCP flags
#define TCP_FIN 0x01
#define TCP_SYN 0x02
#define TCP_RST 0x04
#define TCP_PSH 0x08
#define TCP_ACK 0x10

/* ============================================================================
 * CONFIGURATION STRUCTURE
 * ============================================================================ */

typedef struct {
    char interface[16];
    char bind_ip_str[16];
    uint32_t bind_ip;
    uint16_t bind_port;
    uint8_t mac_address[6];
    int log_level;
    int daemonize;
} server_config_t;

// Global configuration
server_config_t g_config = {
    .interface = "eth0",
    .bind_ip_str = "192.168.1.100",
    .bind_port = 6379,
    .log_level = 1,
    .daemonize = 0
};

// Global state
int g_running = 1;
int g_raw_socket = -1;

/* ============================================================================
 * LOGGING
 * ============================================================================ */

#define LOG_ERROR 0
#define LOG_WARN  1
#define LOG_INFO  2
#define LOG_DEBUG 3

void log_msg(int level, const char *fmt, ...) {
    if (level > g_config.log_level) return;
    
    const char *prefix[] = {"ERROR", "WARN", "INFO", "DEBUG"};
    
    struct timeval tv;
    gettimeofday(&tv, NULL);
    
    char timestamp[32];
    struct tm *tm_info = localtime(&tv.tv_sec);
    strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", tm_info);
    
    fprintf(stderr, "[%s.%03ld] [%s] ", timestamp, tv.tv_usec / 1000,
            prefix[level]);
    
    va_list args;
    va_start(args, fmt);
    vfprintf(stderr, fmt, args);
    va_end(args);
    
    fprintf(stderr, "\n");
}

/* ============================================================================
 * RAW SOCKET SETUP
 * ============================================================================ */

int get_interface_mac(const char *ifname, uint8_t mac[6]) {
    int sock = socket(AF_INET, SOCK_DGRAM, 0);
    if (sock < 0) {
        log_msg(LOG_ERROR, "Failed to create socket for MAC lookup: %s",
                strerror(errno));
        return -1;
    }
    
    struct ifreq ifr;
    strncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);
    
    if (ioctl(sock, SIOCGIFHWADDR, &ifr) < 0) {
        log_msg(LOG_ERROR, "Failed to get MAC address for %s: %s",
                ifname, strerror(errno));
        close(sock);
        return -1;
    }
    
    memcpy(mac, ifr.ifr_hwaddr.sa_data, 6);
    close(sock);
    
    log_msg(LOG_INFO, "Interface %s MAC: %02x:%02x:%02x:%02x:%02x:%02x",
            ifname, mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
    
    return 0;
}

int open_raw_socket(const char *ifname) {
    int sock = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (sock < 0) {
        log_msg(LOG_ERROR, "Failed to create raw socket: %s (are you root?)",
                strerror(errno));
        return -1;
    }
    
    // Get interface index
    struct ifreq ifr;
    strncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);
    if (ioctl(sock, SIOCGIFINDEX, &ifr) < 0) {
        log_msg(LOG_ERROR, "Failed to get interface index for %s: %s",
                ifname, strerror(errno));
        close(sock);
        return -1;
    }
    
    // Bind to interface
    struct sockaddr_ll sll;
    memset(&sll, 0, sizeof(sll));
    sll.sll_family = AF_PACKET;
    sll.sll_ifindex = ifr.ifr_ifindex;
    sll.sll_protocol = htons(ETH_P_ALL);
    
    if (bind(sock, (struct sockaddr*)&sll, sizeof(sll)) < 0) {
        log_msg(LOG_ERROR, "Failed to bind to interface %s: %s",
                ifname, strerror(errno));
        close(sock);
        return -1;
    }
    
    // Enable promiscuous mode (optional, for debugging)
    struct packet_mreq mr;
    memset(&mr, 0, sizeof(mr));
    mr.mr_ifindex = ifr.ifr_ifindex;
    mr.mr_type = PACKET_MR_PROMISC;
    
    if (setsockopt(sock, SOL_PACKET, PACKET_ADD_MEMBERSHIP,
                   &mr, sizeof(mr)) < 0) {
        log_msg(LOG_WARN, "Failed to enable promiscuous mode: %s",
                strerror(errno));
        // Non-fatal, continue
    }
    
    log_msg(LOG_INFO, "Raw socket opened on interface %s", ifname);
    return sock;
}

/* ============================================================================
 * ARP CACHE
 * ============================================================================ */

#define ARP_CACHE_SIZE 256
#define ARP_ENTRY_TIMEOUT 300  // 5 minutes

typedef struct {
    uint32_t ip;
    uint8_t mac[6];
    uint64_t timestamp;
    int valid;
} arp_entry_t;

typedef struct {
    arp_entry_t entries[ARP_CACHE_SIZE];
    int count;
} arp_cache_t;

arp_cache_t g_arp_cache;

void arp_cache_init(void) {
    memset(&g_arp_cache, 0, sizeof(g_arp_cache));
}

int arp_cache_lookup(uint32_t ip, uint8_t mac[6]) {
    uint64_t now = time(NULL);
    
    for (int i = 0; i < ARP_CACHE_SIZE; i++) {
        if (g_arp_cache.entries[i].valid &&
            g_arp_cache.entries[i].ip == ip) {
            
            // Check if expired
            if (now - g_arp_cache.entries[i].timestamp > ARP_ENTRY_TIMEOUT) {
                g_arp_cache.entries[i].valid = 0;
                return -1;
            }
            
            memcpy(mac, g_arp_cache.entries[i].mac, 6);
            return 0;
        }
    }
    
    return -1;
}

void arp_cache_add(uint32_t ip, const uint8_t mac[6]) {
    // Find empty slot or replace oldest
    int idx = -1;
    uint64_t oldest_time = UINT64_MAX;
    
    for (int i = 0; i < ARP_CACHE_SIZE; i++) {
        if (!g_arp_cache.entries[i].valid) {
            idx = i;
            break;
        }
        
        if (g_arp_cache.entries[i].timestamp < oldest_time) {
            oldest_time = g_arp_cache.entries[i].timestamp;
            idx = i;
        }
    }
    
    if (idx >= 0) {
        g_arp_cache.entries[idx].ip = ip;
        memcpy(g_arp_cache.entries[idx].mac, mac, 6);
        g_arp_cache.entries[idx].timestamp = time(NULL);
        g_arp_cache.entries[idx].valid = 1;
        
        struct in_addr addr;
        addr.s_addr = ip;
        log_msg(LOG_DEBUG, "ARP cache updated: %s -> %02x:%02x:%02x:%02x:%02x:%02x",
                inet_ntoa(addr), mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
    }
}

/* ============================================================================
 * PACKET SENDING
 * ============================================================================ */

ssize_t send_raw_packet(int sock, const uint8_t *packet, size_t len) {
    ssize_t sent = write(sock, packet, len);
    if (sent < 0) {
        log_msg(LOG_ERROR, "Failed to send packet: %s", strerror(errno));
        return -1;
    }
    
    if ((size_t)sent != len) {
        log_msg(LOG_WARN, "Partial packet send: %zd/%zu bytes", sent, len);
    }
    
    return sent;
}

/* ============================================================================
 * SIMPLIFIED PACKET STRUCTURES (for demonstration)
 * ============================================================================ */

#pragma pack(push, 1)

typedef struct {
    uint8_t dst_mac[6];
    uint8_t src_mac[6];
    uint16_t ethertype;
} eth_hdr_t;

typedef struct {
    uint8_t version_ihl;
    uint8_t tos;
    uint16_t total_length;
    uint16_t id;
    uint16_t flags_fragment;
    uint8_t ttl;
    uint8_t protocol;
    uint16_t checksum;
    uint32_t src_ip;
    uint32_t dst_ip;
} ip_hdr_t;

typedef struct {
    uint16_t src_port;
    uint16_t dst_port;
    uint32_t seq_num;
    uint32_t ack_num;
    uint8_t data_offset_flags;
    uint8_t flags;
    uint16_t window;
    uint16_t checksum;
    uint16_t urgent_ptr;
} tcp_hdr_t;

typedef struct {
    uint16_t hw_type;
    uint16_t proto_type;
    uint8_t hw_len;
    uint8_t proto_len;
    uint16_t opcode;
    uint8_t sender_mac[6];
    uint32_t sender_ip;
    uint8_t target_mac[6];
    uint32_t target_ip;
} arp_pkt_t;

#pragma pack(pop)

/* ============================================================================
 * CHECKSUM CALCULATION
 * ============================================================================ */

uint16_t ip_checksum(const void *data, size_t len) {
    uint32_t sum = 0;
    const uint16_t *p = (const uint16_t*)data;
    
    while (len > 1) {
        sum += ntohs(*p++);
        len -= 2;
    }
    
    if (len > 0) {
        sum += ((uint8_t*)p)[0] << 8;
    }
    
    while (sum >> 16) {
        sum = (sum & 0xFFFF) + (sum >> 16);
    }
    
    return htons(~sum);
}

uint16_t tcp_checksum(uint32_t src_ip, uint32_t dst_ip,
                      const void *tcp_data, size_t tcp_len) {
    uint32_t sum = 0;
    
    // Pseudo-header
    sum += (src_ip >> 16) & 0xFFFF;
    sum += src_ip & 0xFFFF;
    sum += (dst_ip >> 16) & 0xFFFF;
    sum += dst_ip & 0xFFFF;
    sum += IP_PROTO_TCP;
    sum += tcp_len;
    
    // TCP header + data
    const uint16_t *p = (const uint16_t*)tcp_data;
    size_t remaining = tcp_len;
    
    while (remaining > 1) {
        sum += ntohs(*p++);
        remaining -= 2;
    }
    
    if (remaining > 0) {
        sum += ((uint8_t*)p)[0] << 8;
    }
    
    while (sum >> 16) {
        sum = (sum & 0xFFFF) + (sum >> 16);
    }
    
    return htons(~sum);
}

/* ============================================================================
 * ARP HANDLER
 * ============================================================================ */

void handle_arp_packet(const uint8_t *packet, size_t len) {
    if (len < sizeof(eth_hdr_t) + sizeof(arp_pkt_t)) {
        return;
    }
    
    eth_hdr_t *eth = (eth_hdr_t*)packet;
    arp_pkt_t *arp = (arp_pkt_t*)(packet + sizeof(eth_hdr_t));
    
    // Only handle IPv4 over Ethernet
    if (ntohs(arp->hw_type) != 1 || ntohs(arp->proto_type) != 0x0800) {
        return;
    }
    
    uint16_t opcode = ntohs(arp->opcode);
    
    if (opcode == 1) {  // ARP Request
        // Is it for us?
        if (arp->target_ip == g_config.bind_ip) {
            log_msg(LOG_DEBUG, "ARP request for our IP, sending reply");
            
            // Build ARP reply
            uint8_t reply_buf[sizeof(eth_hdr_t) + sizeof(arp_pkt_t)];
            eth_hdr_t *reply_eth = (eth_hdr_t*)reply_buf;
            arp_pkt_t *reply_arp = (arp_pkt_t*)(reply_buf + sizeof(eth_hdr_t));
            
            // Ethernet header
            memcpy(reply_eth->dst_mac, eth->src_mac, 6);
            memcpy(reply_eth->src_mac, g_config.mac_address, 6);
            reply_eth->ethertype = htons(0x0806);
            
            // ARP packet
            reply_arp->hw_type = htons(1);
            reply_arp->proto_type = htons(0x0800);
            reply_arp->hw_len = 6;
            reply_arp->proto_len = 4;
            reply_arp->opcode = htons(2);  // Reply
            memcpy(reply_arp->sender_mac, g_config.mac_address, 6);
            reply_arp->sender_ip = g_config.bind_ip;
            memcpy(reply_arp->target_mac, arp->sender_mac, 6);
            reply_arp->target_ip = arp->sender_ip;
            
            send_raw_packet(g_raw_socket, reply_buf, sizeof(reply_buf));
        }
    } else if (opcode == 2) {  // ARP Reply
        // Update cache
        arp_cache_add(arp->sender_ip, arp->sender_mac);
    }
}

/* ============================================================================
 * MAIN PACKET PROCESSING
 * ============================================================================ */

void process_packet(const uint8_t *packet, size_t len) {
    if (len < sizeof(eth_hdr_t)) {
        return;
    }
    
    eth_hdr_t *eth = (eth_hdr_t*)packet;
    uint16_t ethertype = ntohs(eth->ethertype);
    
    // Filter: only process packets for us (or broadcast)
    int is_for_us = (memcmp(eth->dst_mac, g_config.mac_address, 6) == 0);
    int is_broadcast = (eth->dst_mac[0] == 0xFF && eth->dst_mac[1] == 0xFF);
    
    if (!is_for_us && !is_broadcast) {
        return;  // Not for us
    }
    
    switch (ethertype) {
    case 0x0806:  // ARP
        handle_arp_packet(packet, len);
        break;
        
    case 0x0800:  // IPv4
        if (len < sizeof(eth_hdr_t) + sizeof(ip_hdr_t)) {
            return;
        }
        
        ip_hdr_t *ip = (ip_hdr_t*)(packet + sizeof(eth_hdr_t));
        
        // Verify IP checksum
        uint16_t orig_csum = ip->checksum;
        ((ip_hdr_t*)ip)->checksum = 0;
        uint16_t calc_csum = ip_checksum(ip, (ip->version_ihl & 0x0F) * 4);
        ((ip_hdr_t*)ip)->checksum = orig_csum;
        
        if (orig_csum != calc_csum) {
            log_msg(LOG_DEBUG, "IP checksum mismatch, dropping");
            return;
        }
        
        // Check if it's for our IP
        if (ip->dst_ip != g_config.bind_ip) {
            return;
        }
        
        if (ip->protocol == IP_PROTO_TCP) {
            // Handle TCP (would call tcp_input here)
            log_msg(LOG_DEBUG, "Received TCP packet");
            // TODO: Call tcp_input() with parsed data
        } else if (ip->protocol == IP_PROTO_ICMP) {
            log_msg(LOG_DEBUG, "Received ICMP packet");
            // TODO: Call handle_icmp()
        }
        break;
        
    default:
        // Ignore other protocols
        break;
    }
}

/* ============================================================================
 * MAIN EVENT LOOP
 * ============================================================================ */

void main_loop(void) {
    uint8_t buffer[2048];
    
    log_msg(LOG_INFO, "Entering main packet processing loop");
    log_msg(LOG_INFO, "Listening on %s:%d", g_config.bind_ip_str, g_config.bind_port);
    
    while (g_running) {
        ssize_t len = read(g_raw_socket, buffer, sizeof(buffer));
        
        if (len < 0) {
            if (errno == EINTR) {
                continue;
            }
            log_msg(LOG_ERROR, "Error reading from socket: %s", strerror(errno));
            break;
        }
        
        if (len == 0) {
            continue;
        }
        
        // Process the packet
        process_packet(buffer, len);
        
        // TODO: Process timers (retransmits, TIME_WAIT, expirations)
        // TODO: Flush send buffers for all connections
    }
    
    log_msg(LOG_INFO, "Main loop exited");
}

/* ============================================================================
 * SIGNAL HANDLERS
 * ============================================================================ */

void signal_handler(int signum) {
    log_msg(LOG_INFO, "Received signal %d, shutting down", signum);
    g_running = 0;
}

void setup_signal_handlers(void) {
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    
    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    
    // Ignore SIGPIPE (broken pipe on send)
    signal(SIGPIPE, SIG_IGN);
}

/* ============================================================================
 * COMMAND LINE PARSING
 * ============================================================================ */

void print_usage(const char *progname) {
    fprintf(stderr, "Usage: %s [options]\n", progname);
    fprintf(stderr, "\nOptions:\n");
    fprintf(stderr, "  --interface <name>    Network interface (default: eth0)\n");
    fprintf(stderr, "  --ip <address>        Bind IP address (default: 192.168.1.100)\n");
    fprintf(stderr, "  --port <port>         Bind port (default: 6379)\n");
    fprintf(stderr, "  --log-level <0-3>     Log level (0=ERROR, 3=DEBUG, default: 1)\n");
    fprintf(stderr, "  --daemonize           Run as daemon\n");
    fprintf(stderr, "  --help                Show this help\n");
    fprintf(stderr, "\n");
}

int parse_args(int argc, char **argv) {
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "--help") == 0 || strcmp(argv[i], "-h") == 0) {
            print_usage(argv[0]);
            return -1;
        } else if (strcmp(argv[i], "--interface") == 0 && i + 1 < argc) {
            strncpy(g_config.interface, argv[++i], sizeof(g_config.interface) - 1);
        } else if (strcmp(argv[i], "--ip") == 0 && i + 1 < argc) {
            strncpy(g_config.bind_ip_str, argv[++i], sizeof(g_config.bind_ip_str) - 1);
        } else if (strcmp(argv[i], "--port") == 0 && i + 1 < argc) {
            g_config.bind_port = atoi(argv[++i]);
        } else if (strcmp(argv[i], "--log-level") == 0 && i + 1 < argc) {
            g_config.log_level = atoi(argv[++i]);
        } else if (strcmp(argv[i], "--daemonize") == 0) {
            g_config.daemonize = 1;
        } else {
            fprintf(stderr, "Unknown option: %s\n", argv[i]);
            print_usage(argv[0]);
            return -1;
        }
    }
    
    return 0;
}

/* ============================================================================
 * MAIN ENTRY POINT
 * ============================================================================ */

int main(int argc, char **argv) {
    printf("===============================================\n");
    printf("  Zero-Copy TCP/IP Stack + Redis Server\n");
    printf("  Systems Engineering Learning Project\n");
    printf("===============================================\n\n");
    
    // Parse command line arguments
    if (parse_args(argc, argv) < 0) {
        return EXIT_FAILURE;
    }
    
    // Convert IP string to binary
    if (inet_pton(AF_INET, g_config.bind_ip_str, &g_config.bind_ip) != 1) {
        fprintf(stderr, "Invalid IP address: %s\n", g_config.bind_ip_str);
        return EXIT_FAILURE;
    }
    
    // Get MAC address of interface
    if (get_interface_mac(g_config.interface, g_config.mac_address) < 0) {
        return EXIT_FAILURE;
    }
    
    // Open raw socket
    g_raw_socket = open_raw_socket(g_config.interface);
    if (g_raw_socket < 0) {
        return EXIT_FAILURE;
    }
    
    // Initialize ARP cache
    arp_cache_init();
    
    // Setup signal handlers
    setup_signal_handlers();
    
    // TODO: Initialize connection pool
    // TODO: Initialize hash table database
    // TODO: Create listener connection
    
    log_msg(LOG_INFO, "Server initialized successfully");
    log_msg(LOG_INFO, "Configuration:");
    log_msg(LOG_INFO, "  Interface: %s", g_config.interface);
    log_msg(LOG_INFO, "  IP: %s", g_config.bind_ip_str);
    log_msg(LOG_INFO, "  Port: %d", g_config.bind_port);
    log_msg(LOG_INFO, "  MAC: %02x:%02x:%02x:%02x:%02x:%02x",
            g_config.mac_address[0], g_config.mac_address[1],
            g_config.mac_address[2], g_config.mac_address[3],
            g_config.mac_address[4], g_config.mac_address[5]);
    
    // Run main event loop
    main_loop();
    
    // Cleanup
    if (g_raw_socket >= 0) {
        close(g_raw_socket);
    }
    
    log_msg(LOG_INFO, "Server shutdown complete");
    
    return EXIT_SUCCESS;
}