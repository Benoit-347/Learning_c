Packet Construction & Utility Functions

/*
 * Complete Packet Construction & Utility Functions
 * 
 * This file provides complete implementations for:
 * - Ethernet/IP/TCP packet construction
 * - Checksum calculations
 * - Response encoding helpers
 * - Database value structures
 * - Memory pools and allocation
 * - Command dispatch
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <arpa/inet.h>
#include <net/ethernet.h>

/* ============================================================================
 * PART 1: PROTOCOL HEADER STRUCTURES
 * ============================================================================ */

#pragma pack(push, 1)

typedef struct eth_header {
    uint8_t  dst_mac[6];
    uint8_t  src_mac[6];
    uint16_t ethertype;  // 0x0800 = IPv4, 0x0806 = ARP, 0x86DD = IPv6
} eth_header_t;

typedef struct ipv4_header {
    uint8_t  version_ihl;     // Version (4 bits) + IHL (4 bits)
    uint8_t  dscp_ecn;        // DSCP (6 bits) + ECN (2 bits)
    uint16_t total_length;
    uint16_t identification;
    uint16_t flags_fragment;  // Flags (3 bits) + Fragment offset (13 bits)
    uint8_t  ttl;
    uint8_t  protocol;        // 1=ICMP, 6=TCP, 17=UDP
    uint16_t checksum;
    uint32_t src_ip;
    uint32_t dst_ip;
} ipv4_header_t;

typedef struct tcp_header {
    uint16_t src_port;
    uint16_t dst_port;
    uint32_t seq_num;
    uint32_t ack_num;
    uint8_t  data_offset_reserved;  // Data offset (4 bits) + Reserved (4 bits)
    uint8_t  flags;                 // CWR, ECE, URG, ACK, PSH, RST, SYN, FIN
    uint16_t window;
    uint16_t checksum;
    uint16_t urgent_ptr;
} tcp_header_t;

#pragma pack(pop)

// TCP flags
#define TCP_FIN 0x01
#define TCP_SYN 0x02
#define TCP_RST 0x04
#define TCP_PSH 0x08
#define TCP_ACK 0x10
#define TCP_URG 0x20
#define TCP_ECE 0x40
#define TCP_CWR 0x80

/* ============================================================================
 * PART 2: CHECKSUM IMPLEMENTATIONS
 * ============================================================================ */

/**
 * Calculate IP header checksum
 * This is the standard Internet checksum (RFC 1071)
 */
uint16_t ip_checksum(const void *data, size_t len) {
    uint32_t sum = 0;
    const uint16_t *p = (const uint16_t*)data;
    
    // Add all 16-bit words
    while (len > 1) {
        sum += ntohs(*p++);
        len -= 2;
    }
    
    // Handle odd byte if present
    if (len > 0) {
        sum += ((uint8_t*)p)[0] << 8;
    }
    
    // Fold 32-bit sum to 16 bits
    while (sum >> 16) {
        sum = (sum & 0xFFFF) + (sum >> 16);
    }
    
    // Return one's complement
    return htons(~sum);
}

/**
 * Calculate TCP/UDP checksum (includes pseudo-header)
 */
uint16_t tcp_udp_checksum(uint32_t src_ip, uint32_t dst_ip,
                          uint8_t protocol, const void *data, size_t len) {
    uint32_t sum = 0;
    
    // Pseudo-header
    sum += (src_ip >> 16) & 0xFFFF;
    sum += src_ip & 0xFFFF;
    sum += (dst_ip >> 16) & 0xFFFF;
    sum += dst_ip & 0xFFFF;
    sum += protocol;
    sum += len;
    
    // TCP/UDP header + data
    const uint16_t *p = (const uint16_t*)data;
    size_t remaining = len;
    
    while (remaining > 1) {
        sum += ntohs(*p++);
        remaining -= 2;
    }
    
    // Handle odd byte
    if (remaining > 0) {
        sum += ((uint8_t*)p)[0] << 8;
    }
    
    // Fold to 16 bits
    while (sum >> 16) {
        sum = (sum & 0xFFFF) + (sum >> 16);
    }
    
    return htons(~sum);
}

/**
 * Verify IP checksum
 */
int verify_ip_checksum(const ipv4_header_t *ip) {
    uint16_t original = ip->checksum;
    ipv4_header_t *mutable_ip = (ipv4_header_t*)ip;
    mutable_ip->checksum = 0;
    
    uint16_t calculated = ip_checksum(ip, (ip->version_ihl & 0x0F) * 4);
    mutable_ip->checksum = original;
    
    return (original == calculated);
}

/**
 * Verify TCP checksum
 */
int verify_tcp_checksum(const ipv4_header_t *ip, const tcp_header_t *tcp) {
    size_t tcp_len = ntohs(ip->total_length) - ((ip->version_ihl & 0x0F) * 4);
    
    uint16_t original = tcp->checksum;
    tcp_header_t *mutable_tcp = (tcp_header_t*)tcp;
    mutable_tcp->checksum = 0;
    
    uint16_t calculated = tcp_udp_checksum(ip->src_ip, ip->dst_ip,
                                           6, tcp, tcp_len);
    mutable_tcp->checksum = original;
    
    return (original == calculated);
}

/* ============================================================================
 * PART 3: PACKET CONSTRUCTION
 * ============================================================================ */

typedef struct packet_buffer {
    uint8_t data[2048];
    size_t len;
} packet_buffer_t;

/**
 * Build Ethernet frame
 */
size_t build_ethernet_frame(uint8_t *buf, const uint8_t dst_mac[6],
                            const uint8_t src_mac[6], uint16_t ethertype,
                            const void *payload, size_t payload_len) {
    eth_header_t *eth = (eth_header_t*)buf;
    
    memcpy(eth->dst_mac, dst_mac, 6);
    memcpy(eth->src_mac, src_mac, 6);
    eth->ethertype = htons(ethertype);
    
    if (payload && payload_len > 0) {
        memcpy(buf + sizeof(eth_header_t), payload, payload_len);
    }
    
    return sizeof(eth_header_t) + payload_len;
}

/**
 * Build IPv4 packet
 */
size_t build_ipv4_packet(uint8_t *buf, uint32_t src_ip, uint32_t dst_ip,
                         uint8_t protocol, uint16_t id, uint8_t ttl,
                         const void *payload, size_t payload_len) {
    ipv4_header_t *ip = (ipv4_header_t*)buf;
    
    ip->version_ihl = 0x45;  // IPv4, 20-byte header
    ip->dscp_ecn = 0;
    ip->total_length = htons(sizeof(ipv4_header_t) + payload_len);
    ip->identification = htons(id);
    ip->flags_fragment = htons(0x4000);  // Don't Fragment
    ip->ttl = ttl;
    ip->protocol = protocol;
    ip->checksum = 0;  // Calculate after
    ip->src_ip = src_ip;
    ip->dst_ip = dst_ip;
    
    // Calculate checksum
    ip->checksum = ip_checksum(ip, sizeof(ipv4_header_t));
    
    // Copy payload
    if (payload && payload_len > 0) {
        memcpy(buf + sizeof(ipv4_header_t), payload, payload_len);
    }
    
    return sizeof(ipv4_header_t) + payload_len;
}

/**
 * Build TCP segment
 */
size_t build_tcp_segment(uint8_t *buf, uint16_t src_port, uint16_t dst_port,
                         uint32_t seq, uint32_t ack, uint8_t flags,
                         uint16_t window, const void *payload, 
                         size_t payload_len) {
    tcp_header_t *tcp = (tcp_header_t*)buf;
    
    tcp->src_port = htons(src_port);
    tcp->dst_port = htons(dst_port);
    tcp->seq_num = htonl(seq);
    tcp->ack_num = htonl(ack);
    tcp->data_offset_reserved = 0x50;  // 20-byte header, no options
    tcp->flags = flags;
    tcp->window = htons(window);
    tcp->checksum = 0;  // Calculate after setting in IP packet
    tcp->urgent_ptr = 0;
    
    // Copy payload
    if (payload && payload_len > 0) {
        memcpy(buf + sizeof(tcp_header_t), payload, payload_len);
    }
    
    return sizeof(tcp_header_t) + payload_len;
}

/**
 * Complete packet builder: Ethernet + IP + TCP
 */
size_t build_tcp_packet(uint8_t *buf,
                        const uint8_t dst_mac[6], const uint8_t src_mac[6],
                        uint32_t src_ip, uint32_t dst_ip,
                        uint16_t src_port, uint16_t dst_port,
                        uint32_t seq, uint32_t ack, uint8_t tcp_flags,
                        uint16_t window, const void *payload, 
                        size_t payload_len) {
    uint8_t *eth_start = buf;
    uint8_t *ip_start = buf + sizeof(eth_header_t);
    uint8_t *tcp_start = ip_start + sizeof(ipv4_header_t);
    
    // Build TCP segment
    size_t tcp_len = build_tcp_segment(tcp_start, src_port, dst_port,
                                       seq, ack, tcp_flags, window,
                                       payload, payload_len);
    
    // Build IP packet
    static uint16_t ip_id = 0;
    size_t ip_len = build_ipv4_packet(ip_start, src_ip, dst_ip,
                                      6, ip_id++, 64,  // protocol=6 (TCP), TTL=64
                                      tcp_start, tcp_len);
    
    // Calculate TCP checksum now that IP header is complete
    tcp_header_t *tcp = (tcp_header_t*)tcp_start;
    tcp->checksum = tcp_udp_checksum(src_ip, dst_ip, 6, tcp_start, tcp_len);
    
    // Build Ethernet frame
    size_t total_len = build_ethernet_frame(eth_start, dst_mac, src_mac,
                                           0x0800,  // IPv4
                                           ip_start, ip_len);
    
    return total_len;
}

/* ============================================================================
 * PART 4: DATABASE VALUE STRUCTURES
 * ============================================================================ */

typedef enum {
    DB_TYPE_STRING = 0,
    DB_TYPE_LIST,
    DB_TYPE_SET,
    DB_TYPE_ZSET,
    DB_TYPE_HASH,
    DB_TYPE_STREAM
} db_value_type_t;

typedef struct db_value {
    db_value_type_t type;
    uint64_t last_access_time;
    int64_t expiration_ms;  // -1 = no expiration
    
    union {
        // String type
        struct {
            size_t len;
            uint8_t data[];  // Flexible array
        } string;
        
        // List type
        struct quicklist *list;
        
        // Set type (using hash table with NULL values)
        struct hash_table *set;
        
        // Sorted set
        struct {
            struct skiplist *sl;
            struct hash_table *dict;  // member -> score
        } zset;
        
        // Hash type
        struct hash_table *hash;
        
        // Stream type (future)
        void *stream;
    };
} db_value_t;

/**
 * Create string value
 */
db_value_t* db_value_create_string(const uint8_t *data, size_t len) {
    db_value_t *val = malloc(sizeof(db_value_t) + len);
    if (!val) return NULL;
    
    val->type = DB_TYPE_STRING;
    val->last_access_time = time(NULL);
    val->expiration_ms = -1;
    val->string.len = len;
    memcpy(val->string.data, data, len);
    
    return val;
}

/**
 * Create list value
 */
db_value_t* db_value_create_list(void) {
    db_value_t *val = malloc(sizeof(db_value_t));
    if (!val) return NULL;
    
    val->type = DB_TYPE_LIST;
    val->last_access_time = time(NULL);
    val->expiration_ms = -1;
    val->list = quicklist_new();
    
    return val;
}

/**
 * Create sorted set value
 */
db_value_t* db_value_create_zset(void) {
    db_value_t *val = malloc(sizeof(db_value_t));
    if (!val) return NULL;
    
    val->type = DB_TYPE_ZSET;
    val->last_access_time = time(NULL);
    val->expiration_ms = -1;
    val->zset.sl = skiplist_create();
    val->zset.dict = hash_table_create(16);
    
    return val;
}

/**
 * Free database value
 */
void db_value_free(db_value_t *val) {
    if (!val) return;
    
    switch (val->type) {
    case DB_TYPE_STRING:
        // String data is inline, just free the struct
        break;
        
    case DB_TYPE_LIST:
        quicklist_free(val->list);
        break;
        
    case DB_TYPE_SET:
        hash_table_free(val->set);
        break;
        
    case DB_TYPE_ZSET:
        skiplist_free(val->zset.sl);
        hash_table_free(val->zset.dict);
        break;
        
    case DB_TYPE_HASH:
        hash_table_free(val->hash);
        break;
        
    default:
        break;
    }
    
    free(val);
}

/* ============================================================================
 * PART 5: RESP RESPONSE ENCODING (COMPLETE)
 * ============================================================================ */

/**
 * Send data over TCP connection
 */
int tcp_send_data(struct tcp_connection *conn, const uint8_t *data, size_t len) {
    // In real implementation, this would:
    // 1. Copy data to send buffer
    // 2. Update TCP state (snd_nxt)
    // 3. Build and send TCP segments
    // 4. Handle flow control (check snd_wnd)
    
    // Simplified: just copy to send buffer
    size_t space = TCP_SEND_BUF_SIZE - conn->send_count;
    if (len > space) {
        len = space;  // Truncate
    }
    
    for (size_t i = 0; i < len; i++) {
        conn->send_buf[conn->send_head] = data[i];
        conn->send_head = (conn->send_head + 1) % TCP_SEND_BUF_SIZE;
    }
    conn->send_count += len;
    
    // Trigger actual send
    // flush_tcp_send_buffer(conn);
    
    return len;
}

/**
 * Send RESP simple string: +OK\r\n
 */
void send_simple_string(struct tcp_connection *conn, const char *str) {
    char buf[512];
    int len = snprintf(buf, sizeof(buf), "+%s\r\n", str);
    tcp_send_data(conn, (uint8_t*)buf, len);
}

/**
 * Send RESP error: -ERR message\r\n
 */
void send_error(struct tcp_connection *conn, const char *err) {
    char buf[512];
    int len = snprintf(buf, sizeof(buf), "-%s\r\n", err);
    tcp_send_data(conn, (uint8_t*)buf, len);
}

/**
 * Send RESP integer: :123\r\n
 */
void send_integer(struct tcp_connection *conn, int64_t val) {
    char buf[64];
    int len = snprintf(buf, sizeof(buf), ":%lld\r\n", (long long)val);
    tcp_send_data(conn, (uint8_t*)buf, len);
}

/**
 * Send RESP bulk string: $6\r\nfoobar\r\n
 */
void send_bulk_string(struct tcp_connection *conn, 
                      const uint8_t *data, size_t len) {
    char header[64];
    int header_len = snprintf(header, sizeof(header), "$%zu\r\n", len);
    
    tcp_send_data(conn, (uint8_t*)header, header_len);
    tcp_send_data(conn, data, len);
    tcp_send_data(conn, (uint8_t*)"\r\n", 2);
}

/**
 * Send RESP null bulk string: $-1\r\n
 */
void send_null_bulk(struct tcp_connection *conn) {
    tcp_send_data(conn, (uint8_t*)"$-1\r\n", 5);
}

/**
 * Send RESP array header: *3\r\n
 */
void send_array_header(struct tcp_connection *conn, int count) {
    char buf[64];
    int len = snprintf(buf, sizeof(buf), "*%d\r\n", count);
    tcp_send_data(conn, (uint8_t*)buf, len);
}

/**
 * Send RESP null array: *-1\r\n
 */
void send_null_array(struct tcp_connection *conn) {
    tcp_send_data(conn, (uint8_t*)"*-1\r\n", 5);
}

/* ============================================================================
 * PART 6: COMPLETE COMMAND HANDLERS
 * ============================================================================ */

/**
 * Compare string (case-insensitive)
 */
int strcasecmp_n(const uint8_t *s1, const char *s2, size_t n) {
    for (size_t i = 0; i < n; i++) {
        int c1 = (s1[i] >= 'A' && s1[i] <= 'Z') ? s1[i] + 32 : s1[i];
        int c2 = (s2[i] >= 'A' && s2[i] <= 'Z') ? s2[i] + 32 : s2[i];
        
        if (c1 != c2) return c1 - c2;
        if (c1 == 0) return 0;
    }
    return 0;
}

/**
 * PING [message]
 */
void cmd_ping(struct tcp_connection *conn, uint8_t **args, 
              size_t *arg_lens, int argc) {
    if (argc == 1) {
        send_simple_string(conn, "PONG");
    } else {
        send_bulk_string(conn, args[1], arg_lens[1]);
    }
}

/**
 * ECHO message
 */
void cmd_echo(struct tcp_connection *conn, uint8_t **args, 
              size_t *arg_lens, int argc) {
    send_bulk_string(conn, args[1], arg_lens[1]);
}

/**
 * SET key value [EX seconds] [PX milliseconds] [NX|XX]
 */
void cmd_set(struct tcp_connection *conn, struct hash_table *db,
             uint8_t **args, size_t *arg_lens, int argc) {
    // Parse options
    int64_t expire_ms = -1;
    int nx = 0, xx = 0;
    
    for (int i = 3; i < argc; i++) {
        if (arg_lens[i] == 2 && strcasecmp_n(args[i], "EX", 2) == 0) {
            if (i + 1 < argc) {
                // Parse seconds
                char buf[32];
                size_t len = (arg_lens[i+1] < 31) ? arg_lens[i+1] : 31;
                memcpy(buf, args[i+1], len);
                buf[len] = '\0';
                expire_ms = atoll(buf) * 1000;
                i++;
            }
        } else if (arg_lens[i] == 2 && strcasecmp_n(args[i], "PX", 2) == 0) {
            if (i + 1 < argc) {
                // Parse milliseconds
                char buf[32];
                size_t len = (arg_lens[i+1] < 31) ? arg_lens[i+1] : 31;
                memcpy(buf, args[i+1], len);
                buf[len] = '\0';
                expire_ms = atoll(buf);
                i++;
            }
        } else if (arg_lens[i] == 2 && strcasecmp_n(args[i], "NX", 2) == 0) {
            nx = 1;
        } else if (arg_lens[i] == 2 && strcasecmp_n(args[i], "XX", 2) == 0) {
            xx = 1;
        }
    }
    
    // Check NX/XX conditions
    db_value_t *existing = hash_get(db, args[1], arg_lens[1]);
    
    if (nx && existing) {
        send_null_bulk(conn);
        return;
    }
    if (xx && !existing) {
        send_null_bulk(conn);
        return;
    }
    
    // Create new value
    db_value_t *val = db_value_create_string(args[2], arg_lens[2]);
    if (!val) {
        send_error(conn, "ERR out of memory");
        return;
    }
    
    val->expiration_ms = expire_ms;
    
    // Set in database
    if (existing) {
        db_value_free(existing);
    }
    hash_set(db, args[1], arg_lens[1], val);
    
    send_simple_string(conn, "OK");
}

/**
 * GET key
 */
void cmd_get(struct tcp_connection *conn, struct hash_table *db,
             uint8_t **args, size_t *arg_lens, int argc) {
    db_value_t *val = hash_get(db, args[1], arg_lens[1]);
    
    if (!val) {
        send_null_bulk(conn);
        return;
    }
    
    // Check expiration
    if (val->expiration_ms >= 0) {
        uint64_t now_ms = time(NULL) * 1000;
        if (now_ms >= (uint64_t)val->expiration_ms) {
            // Expired
            hash_delete(db, args[1], arg_lens[1]);
            db_value_free(val);
            send_null_bulk(conn);
            return;
        }
    }
    
    if (val->type != DB_TYPE_STRING) {
        send_error(conn, "WRONGTYPE Operation against a key holding the wrong kind of value");
        return;
    }
    
    val->last_access_time = time(NULL);
    send_bulk_string(conn, val->string.data, val->string.len);
}

/**
 * DEL key [key ...]
 */
void cmd_del(struct tcp_connection *conn, struct hash_table *db,
             uint8_t **args, size_t *arg_lens, int argc) {
    int deleted = 0;
    
    for (int i = 1; i < argc; i++) {
        db_value_t *val = hash_get(db, args[i], arg_lens[i]);
        if (val) {
            hash_delete(db, args[i], arg_lens[i]);
            db_value_free(val);
            deleted++;
        }
    }
    
    send_integer(conn, deleted);
}

/**
 * LPUSH key element [element ...]
 */
void cmd_lpush(struct tcp_connection *conn, struct hash_table *db,
               uint8_t **args, size_t *arg_lens, int argc) {
    db_value_t *val = hash_get(db, args[1], arg_lens[1]);
    
    if (!val) {
        val = db_value_create_list();
        hash_set(db, args[1], arg_lens[1], val);
    }
    
    if (val->type != DB_TYPE_LIST) {
        send_error(conn, "WRONGTYPE");
        return;
    }
    
    for (int i = 2; i < argc; i++) {
        quicklist_push_head(val->list, args[i], arg_lens[i]);
    }
    
    send_integer(conn, val->list->count);
}

/**
 * LPOP key
 */
void cmd_lpop(struct tcp_connection *conn, struct hash_table *db,
              uint8_t **args, size_t *arg_lens, int argc) {
    db_value_t *val = hash_get(db, args[1], arg_lens[1]);
    
    if (!val) {
        send_null_bulk(conn);
        return;
    }
    
    if (val->type != DB_TYPE_LIST) {
        send_error(conn, "WRONGTYPE");
        return;
    }
    
    uint8_t *data;
    size_t len;
    
    if (quicklist_pop_head(val->list, &data, &len) < 0) {
        send_null_bulk(conn);
        return;
    }
    
    send_bulk_string(conn, data, len);
    free(data);
    
    // Remove key if list is empty
    if (val->list->count == 0) {
        hash_delete(db, args[1], arg_lens[1]);
        db_value_free(val);
    }
}

/**
 * LRANGE key start stop
 */
void cmd_lrange(struct tcp_connection *conn, struct hash_table *db,
                uint8_t **args, size_t *arg_lens, int argc) {
    db_value_t *val = hash_get(db, args[1], arg_lens[1]);
    
    if (!val) {
        send_array_header(conn, 0);
        return;
    }
    
    if (val->type != DB_TYPE_LIST) {
        send_error(conn, "WRONGTYPE");
        return;
    }
    
    // Parse start and stop
    char buf[32];
    
    size_t len = (arg_lens[2] < 31) ? arg_lens[2] : 31;
    memcpy(buf, args[2], len);
    buf[len] = '\0';
    int start = atoi(buf);
    
    len = (arg_lens[3] < 31) ? arg_lens[3] : 31;
    memcpy(buf, args[3], len);
    buf[len] = '\0';
    int stop = atoi(buf);
    
    // Handle negative indices
    if (start < 0) start = val->list->count + start;
    if (stop < 0) stop = val->list->count + stop;
    
    if (start < 0) start = 0;
    if (stop >= (int)val->list->count) stop = val->list->count - 1;
    
    if (start > stop) {
        send_array_header(conn, 0);
        return;
    }
    
    // Send array header
    send_array_header(conn, stop - start + 1);
    
    // Iterate and send elements
    typedef struct {
        struct tcp_connection *conn;
    } range_ctx_t;
    
    range_ctx_t ctx = { .conn = conn };
    
    void send_element(const uint8_t *data, size_t len, void *arg) {
        range_ctx_t *ctx = (range_ctx_t*)arg;
        send_bulk_string(ctx->conn, data, len);
    }
    
    quicklist_iter(val->list, start, stop, send_element, &ctx);
}

/**
 * Command dispatch table
 */
typedef void (*cmd_handler_t)(struct tcp_connection *conn,
                              struct hash_table *db,
                              uint8_t **args, size_t *arg_lens, int argc);

typedef struct {
    const char *name;
    int min_args;  // Minimum arguments (including command name)
    cmd_handler_t handler;
} command_entry_t;

command_entry_t command_table[] = {
    {"PING", 1, (cmd_handler_t)cmd_ping},
    {"ECHO", 2, (cmd_handler_t)cmd_echo},
    {"SET", 3, cmd_set},
    {"GET", 2, cmd_get},
    {"DEL", 2, cmd_del},
    {"LPUSH", 3, cmd_lpush},
    {"RPUSH", 3, cmd_lpush},  // Same implementation
    {"LPOP", 2, cmd_lpop},
    {"LRANGE", 4, cmd_lrange},
    {NULL, 0, NULL}
};

/**
 * Dispatch command
 */
void dispatch_command(struct tcp_connection *conn, struct hash_table *db,
                     uint8_t **args, size_t *arg_lens, int argc) {
    if (argc == 0) return;
    
    // Find command
    for (int i = 0; command_table[i].name; i++) {
        size_t cmd_len = strlen(command_table[i].name);
        
        if (arg_lens[0] == cmd_len &&
            strcasecmp_n(args[0], command_table[i].name, cmd_len) == 0) {
            
            // Check argument count
            if (argc < command_table[i].min_args) {
                send_error(conn, "ERR wrong number of arguments");
                return;
            }
            
            // Execute command
            command_table[i].handler(conn, db, args, arg_lens, argc);
            return;
        }
    }
    
    send_error(conn, "ERR unknown command");
}

/* ============================================================================
 * PART 7: MEMORY POOL FOR SMALL ALLOCATIONS
 * ============================================================================ */

#define POOL_BLOCK_SIZE 4096
#define POOL_MAX_ALLOC 256

typedef struct pool_block {
    uint8_t data[POOL_BLOCK_SIZE];
    size_t used;
    struct pool_block *next;
} pool_block_t;

typedef struct memory_pool {
    pool_block_t *current;
    pool_block_t *blocks;
} memory_pool_t;

memory_pool_t* pool_create(void) {
    memory_pool_t *pool = malloc(sizeof(memory_pool_t));
    pool->current = malloc(sizeof(pool_block_t));
    pool->current->used = 0;
    pool->current->next = NULL;
    pool->blocks = pool->current;
    return pool;
}

void* pool_alloc(memory_pool_t *pool, size_t size) {
    if (size > POOL_MAX_ALLOC) {
        // Fall back to malloc for large allocations
        return malloc(size);
    }
    
    // Align to 8 bytes
    size = (size + 7) & ~7;
    
    if (pool->current->used + size > POOL_BLOCK_SIZE) {
        // Need new block
        pool_block_t *block = malloc(sizeof(pool_block_t));
        block->used = 0;
        block->next = pool->blocks;
        pool->blocks = block;
        pool->current = block;
    }
    
    void *ptr = pool->current->data + pool->current->used;
    pool->current->used += size;
    return ptr;
}

void pool_reset(memory_pool_t *pool) {
    // Reset all blocks (don't free, just reset used counters)
    pool_block_t *block = pool->blocks;
    while (block) {
        block->used = 0;
        block = block->next;
    }
    pool->current = pool->blocks;
}

void pool_destroy(memory_pool_t *pool) {
    pool_block_t *block = pool->blocks;
    while (block) {
        pool_block_t *next = block->next;
        free(block);
        block = next;
    }
    free(pool);
}

/* ============================================================================
 * USAGE EXAMPLE
 * ============================================================================ */

void example_usage(void) {
    // Build a complete TCP packet
    uint8_t packet[2048];
    uint8_t dst_mac[6] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55};
    uint8_t src_mac[6] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF};
    
    const char *payload = "GET /\r\n";
    
    size_t len = build_tcp_packet(
        packet,
        dst_mac, src_mac,
        htonl(0xC0A80101),  // 192.168.1.1
        htonl(0xC0A80102),  // 192.168.1.2
        12345,  // src port
        80,     // dst port (HTTP)
        1000,   // seq
        2000,   // ack
        TCP_ACK | TCP_PSH,
        8192,   // window
        payload, strlen(payload)
    );
    
    printf("Built TCP packet: %zu bytes\n", len);
    
    // Verify checksums
    ipv4_header_t *ip = (ipv4_header_t*)(packet + sizeof(eth_header_t));
    tcp_header_t *tcp = (tcp_header_t*)(packet + sizeof(eth_header_t) + 
                                        sizeof(ipv4_header_t));
    
    printf("IP checksum valid: %d\n", verify_ip_checksum(ip));
    printf("TCP checksum valid: %d\n", verify_tcp_checksum(ip, tcp));
}

/* End of file */